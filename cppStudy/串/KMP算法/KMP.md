# KMP算法  
在暴力匹配中，每趟匹配失败都是模式后移一位再从头开始比较。而某趟已匹配相等的字符序列是模式的某个前缀，这种频繁的重复比较相当于模式串在不断地进行自我比较，这就是其低效率的根源。  

因此，可以从分析模式本身的结构着手，如果已匹配相等的前缀序列中有某个后缀正好是模式地前缀，那么就可以将模式向后滑动到与这些相等字符对其的位置，主串i指针无需回溯，并从该位置开始继续比较。而漠视向后滑动位数的计算仅与模式本身的结构有关，与主串无关。  

---
## 1.字符串的前缀、后缀和部分匹配值  
- 前缀：除最后一个字符以外，字符串的所有头部字串。  
- 后缀：除第一个字符以外，字符串的所有尾部字串。
- 部分匹配值：字符串的前缀和后缀的最长相等前后缀长度。

以'ababa'为例进行说明：  
- 'a'的前缀和后缀都为空集，最长相等前后缀长度为0；  
- 'ab'的前缀为{a}，后缀为{b}，前缀后缀无交集，最长相等前后缀长度为0；  
- 'aba'的前缀为{a, ab}，后缀为{a, ba}，前缀和后缀的交集为{a}，最长相等前后缀长度为1；  
- 'abab'的前缀为{a, ab, aba}，后缀为{b, ab, bab}，前缀和后缀的交集为{ab}，最长相等前后缀长度为2；
- 'ababa'的前缀为{a, ab, aba, abab}，后缀为{a, ba, aba, baba}，前缀和后缀的交集为{a, aba}，最长相等前后缀长度为3。  

故字符串'ababa'的部分匹配值为00123。  

### 部分匹配值的使用：

![](/assets/KMP.png)

字串全部比较完成，匹配成功。整个匹配过程中主串始终没有回退，故KMP算法可以在O(n+m)的时间数量级上完成串的模式匹配操作，大大提高了匹配效率。  

某趟发生失配时，如果对应的部分匹配值为0，那么表示已匹配相等序列中没有相等的前后缀，此时移动的位数最大，直接将字串首字符后移到主串i位置进行下一趟比较；  
如果已匹配相等序列中存在最大相等前后缀（可理解为首尾重合），那么将字串向右滑动到和该项等前后缀对齐（这部分字符下一趟显然不需要比较），然后从主串i位置进行下一趟比较。  

---
## 2.KMP算法的原理  
**公式：移动位数 = 已匹配的字符数 - 对应的部分匹配值**  
大致原理是找到不匹配的位置后，保留字串中已经匹配正确的部分，然后在子串中寻找这一部分，能找到就从相同的这一部分的末尾继续匹配，找不到就跳过一个子串长度再进行匹配。  

**新起点i仅与子串有关**  

---
## 3.代码实现  
### 1. next数组  
next 数组的计算是 KMP 算法中的关键步骤，它用于指导在模式匹配时的回溯操作。next 数组的每个元素代表了模式中某个位置之前的子串的最长相等的前缀和后缀的长度。  
初始化 next[0] 为 -1，i 和 j 分别为 0 和 -1。

在一个循环中，比较当前模式字符 T[i] 和 T[j]：

如果 j 是 -1 或者 T[i] 等于 T[j]，说明找到了相等的前缀和后缀，将 next[i+1] 设置为 j+1，然后递增 i 和 j。

如果 T[i] 不等于 T[j]，则将 j 更新为 next[j]。这里的目标是找到一个较短的相等前缀和后缀，因此将 j 回退到 next[j]，继续比较。

重复这个过程直到计算完整个 next 数组。

这个过程的关键是在发现不匹配时，通过 next 数组中的信息，使得模式指针 j 尽可能快地回退到一个可能与当前文本字符匹配的位置。这样就避免了在文本和模式之间做不必要的比较，提高了匹配的效率。

通过正确计算 next 数组，KMP 算法能够在匹配失败时有效地利用已匹配的信息，避免重复的工作，从而提高字符串匹配的效率。
