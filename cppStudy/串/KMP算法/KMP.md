# KMP算法  
在暴力匹配中，每趟匹配失败都是模式后移一位再从头开始比较。而某趟已匹配相等的字符序列是模式的某个前缀，这种频繁的重复比较相当于模式串在不断地进行自我比较，这就是其低效率的根源。  

因此，可以从分析模式本身的结构着手，如果已匹配相等的前缀序列中有某个后缀正好是模式地前缀，那么就可以将模式向后滑动到与这些相等字符对其的位置，主串i指针无需回溯，并从该位置开始继续比较。而漠视向后滑动位数的计算仅与模式本身的结构有关，与主串无关。  

## 1.字符串的前缀、后缀和部分匹配值  
- 前缀：除最后一个字符以外，字符串的所有头部字串。  
- 后缀：除第一个字符以外，字符串的所有尾部字串。
- 部分匹配值：字符串的前缀和后缀的最长相等前后缀长度。

以'ababa'为例进行说明：  
- 'a'的前缀和后缀都为空集，最长相等前后缀长度为0；  
- 'ab'的前缀为{a}，后缀为{b}，前缀后缀无交集，最长相等前后缀长度为0；  
- 'aba'的前缀为{a, ab}，后缀为{a, ba}，前缀和后缀的交集为{a}，最长相等前后缀长度为1；  
- 'abab'的前缀为{a, ab, aba}，后缀为{b, ab, bab}，前缀和后缀的交集为{ab}，最长相等前后缀长度为2；
- 'ababa'的前缀为{a, ab, aba, abab}，后缀为{a, ba, aba, baba}，前缀和后缀的交集为{a, aba}，最长相等前后缀长度为3。  

故字符串'ababa'的部分匹配值为00123。  

### 部分匹配值的使用：

![](/assets/KMP.png)

字串全部比较完成，匹配成功。整个匹配过程中主串始终没有回退，故KMP算法可以在O(n+m)的时间数量级上完成串的模式匹配操作，大大提高了匹配效率。  

某趟发生失配时，如果对应的部分匹配值为0，那么表示已匹配相等序列中没有相等的前后缀，此时移动的位数最大，直接将字串首字符后移到主串i位置进行下一趟比较；  
如果已匹配相等序列中存在最大相等前后缀（可理解为首尾重合），那么将字串向右滑动到和该项等前后缀对齐（这部分字符下一趟显然不需要比较），然后从主串i位置进行下一趟比较。  

## 2.KMP算法的原理  
**公式：移动位数 = 已匹配的字符数 - 对应的部分匹配值**  
大致原理是找到不匹配的位置后，保留字串中已经匹配正确的部分，然后在子串中寻找这一部分，能找到就从相同的这一部分的末尾继续匹配，找不到就跳过一个子串长度再进行匹配。  

**新起点i仅与子串有关**  

